= Ruby Curious
Past instructors include Adam Bair, Pradeep Elankumaran, and Paul Ostazeski

In this course we'll introduce you to the wonderfully curious world of Ruby. You've heard the hype and can no longer hold back you brain's intrinsic thirst for knowledge. Will it make you toast in the morning? Is it your best friend? Can it really solve world hunger?

=== Installfest

* Who needs help getting ruby up and running on their machines?
* We can even start this pre-class if we can get there early
* Might want to mention this in the introduction email (come early for install help?)

=== Introduction

* not the typical slideshow class, more interactive than that.
* follow along, type stuff in, get help on the fly
* speak up, ask questions, offer opinions
* remember, learning is fun ;)

=== History
* ruby is almost 15 years old
* conceived by Yukihiro Matsumoto (Matz) in 1993
* first public release (0.95) in december 05
* 1.0 on christmas of 06
* Ruby-talk mailing list (first in english) started when ruby 1.3 was released in 99

=== Philosphy
* Matz designed Ruby with programmer productivity and happiness in mind
* Takes the focus away from making the machine run faster ** but instead making the programmer faster, happier and more productive.
* Ruby follows the principals of the Path of Least Surprise (POLS?). The language was designed to be consistent in how it operates so that ruby programmers can usually guess the right method to use or how something is going to respond/perform/etc.
  
  example:
    String#upcase has a matching #downcase method
    instead of upper and lower (choosing up/down instead for logical consistency)

* Ruby is awesome. It's just more fun to say than Python... way more fun to say then Perl.

=== An Introduction to the Ruby Environment
* most Ruby files have an .rb extension
* you can run a Ruby file by typing
    ruby filename.rb
* Ruby is an intepreted language (not compiled), read line by line by the Ruby interpreter


==== Interactive Ruby Console (irb)
* You can execute live Ruby code on the fly
* A great place to test out simple Ruby code

==== Variables
* store anything
* created on the fly
* starts with a lower*case letter
* contains numbers, underscores, or dashes
* instance variables start with an at sign (@)
* class variables start with a double at sign (@@)

==== Comments

    # denotes a comment
    # this is not executed by the Ruby interpreter

==== Printing to the Screen

    puts  #=> print a line to the screen automatically adding a new line character
    print #=> print a line to the screen without adding a new line character
    gets  #=> get information from the user (gets.chomp will remove newlines \n)
    p     #=> pretty print an object

=== Lab 01: Hello World [ lab_01_hello_world.rb ]
* Create a ruby file
* Display 'hello world' when the file is run
* (you can run the file by typing 'ruby name_of_file.rb'

==== Objectect Inspection
* object.inspect will give you good information on an object
* works well when debugging
* commonly used like:

    puts something.inspect
    p something #=> is shorthand for puts something.inspect

==== Strings
* double quotes WILL evaluate it's contents and is called 'string interpolation'
    happy = 'smiles'
    "I'm full of #{happy}!" #=> "I'm full of smiles!"

* single quotes will NOT interpolate and execute

    'Happy'           #=> 'happy'
    "Happy #{1+1}"    #=> 'happy 2'
    'Happy ' + 2.to_s #=> 'happy 2'
    'Happy ' += 2     #=> 'happy 2'
    'Happy'.length    #=> 5
    'Happy'.reverse   #=> 'yppaH'
    'Happy'.downcase  #=> 'happy'

=== Lab 02: What is your name? [ lab_02_get_name.rb ]
* Ask the user for their name
* Capture the name to a variable
* Perform a string operation on their name (reverse, upcase, etc)
* Display the result on screen

==== String Operations

* cast a non-String to a String

    5       #=> 5
    5.to_s  #=> "5"

* sub-strings

    "hello"[0,  1] #=> 'h'
    "hello"[0,  2] #=> 'he'
    "hello"[-1, 1] #=> 'o'

* String#split
    
    "This is a test".split #=> ["This", "is", "a", "test"]
    "zomg".split(//)       #=> ["z", "o", "m", "g"] 
    "zomg".split('o')        #=> ["z", "mg"] 

=== Lab 03: Pig Latin [ lab_03_pig_latin.rb ]
* Ask the user for a word
* Translate the word to pig latin
* Display the translation on screen
* Pig Latin algorithm:
* -take the first letter of the word
* -move it to the end
* -add ay

==== Symbols
* identifiers or immutable strings
* symbols look like :this

    happy = :smile
  
==== Integers/Fixnum
    1       #=> 1
    1+1     #=> 2
    1.zero? #=> false

    1.upto(10) do |number|
      puts number
    end

    # dividing two integers performs integer division
    3/1.5 #=> float
    3/2   #=> 1

==== Arrays

    Array.new       #=> []
    []              #=> []
    [1,2]           #=> [1, 2]
    [1,2] + [3, 4]  #=> [1,2,3,4]
    [1,2,3].size    #=> 3

==== Iteration / Enumerable

* standard block format

    ['car', 'truck'].each do |word|
      puts word
    end

* shorthand block format

    ['car', 'truck'].each {|word| puts word}

* map/collect #=> returns a collection
    
    test = ['car', 'truck'].map{|w| w.reverse} #=> ['rac', 'kcurt']

* inject (awesome)
    # iterates over a collection but provides a persistent variable across all iterations

    numbers = [1, 2, 3]
    numbers.inject(0) {|sum, num| sum += num} #=> 6

    # which is functionally equivilent to:

    numbers = [1, 2, 3]
    sum = 0
    numbers.each {|num| sum += num}
    sum #=> 6

==== Array#join

    ["This", "is", "a", "test"].join       #=> "This is a test"
    ["This", "is", "a", "test"].join(", ") #=> "This, is, a, test"
    ["This", "is", "a", "test"].join("|")  #=> "This|is|a|test"
  
=== Lab 04: Full-on Pig Latin [ lab_04_full_on_pig_latin.rb ]
* Convert a sentence to pig latin with help from lab 3 (Pig Latin)
* ...there may be edge cases ("th")

==== Ranges
    "a".."z".each {|char| puts char}   #=> prints the alphabet
    1..100.each {|num| puts num}       #=> counts from 1 to 100
    1.upto(10).each {|num| puts num}   #=> counts from 1 to 10 
    10.downto(1).each {|num| puts num} #=> counts from 10 to 1 

==== Hashes
    Hash.new        #=> {}
    {}              #=> {}
    {'name' => 'jack'}              #=> {'name' => 'jack'}
    {'name' => 'beth', 'age' => 22} #=> {'name' => 'beth', 'age' => 22}

    {'name' => 'beth', 'age' => 22}.each do |key, value|
      puts "#{key}:#{value}"
    end

    {:oranges => 4.50, :apples => 3.20} #=> uses symbols as keys (common in Rails)

=== Lab 05: Grocery List [ lab_05_grocery_list.rb ]
* create a list of groceries 
* print groceries with prices
* sum the prices (total)

==== Control structures

==== if/else
    
    if condition
      'do if true'
    else
      'do if false' #=> this is so not going to ever happen
    end

    if name == 'adam'
      puts 'awesome'
    elsif name == 'paul'
      puts 'even more awesome'
    else
      puts 'students are awesome!'
    end
    
==== unless (opposite of if/else)

    unless condition
      'do if false'
    else
      'do if true'
    end

    # it's worth noting that unless cannot use elsif #=> unlessif doesn't exist ;)
    # this is much more useful when used as a statement modifier

==== ternary (single line if/else)

    condition ? 'do if true' : 'do if false'

    # beware, these are good for SIMPLE logic
    # nesting is a bad idea... ?:?:?:: doesn't make much sense.

==== statement modifiers
* ruby lets you do awesome things like this:

    print 'happy' if adam.happy?
    print 'happy' unless adam.sad?

    # statement modifiers almost read like english -- impressive ;)

==== case (Ruby's switch statement)
* case statments have TWO forms:

- 1.) Simple

    name = 'Jack'

    case
      when name == "Jack"
        'I am Jack'
      when name == "Jane"
        'I am Jane'
      else 
        'who am I'
    end                   #=> "I am Jack"

- 2.) Awesome

    name = 'Jack'

    case name
      when "Jack"
        'I am Jack'
      when "Jane"
        'I am Jane'
      else
        'who am I'
    end                   #=> "I am Jack"

=== Lab 06: Grocery List Commentary [ lab_06_grocery_list_commentary.rb ]
* Iterate over a list of groceries
* Print out cheap if the item is within a certain price range
* Print out expensive if the item is above a certain price

==== Methods
  
* no arguments

    def age
      22
    end

    age #=> 22

* with arguments

    def full_name(first_name, last_name)
      "#{first_name} #{last_name}"
    end

    full_name('adam', 'bair') #=> 'adam bair'

* splat arguments

    def mood(disposition, *everything_else)
      puts mood
      puts everything_else.inspect
    end

    mood('cheery', 4, 3, 'test', [5,6])
      #=> cheery
      #=> [4, 3, 'test', [5,6]] 

* return is implicit, last thing in a method will be returned

    def name
      'bently'
      'sven'
    end

    # would return 'sven'

* an explicit return will stop execution of that method on the line that called return 

    def name
      return 'bently'
      'sven'
    end

    # would return 'bently'

==== Method Suffixes
* *exclamation* *point*: usually indicates that something destructive is going to happen.

  - an example of this would be Array#sort!. The Array#sort! method modifies the current object instead of returning a new object with the modifications. Normally Ruby will make a copy of an object, do the requested operation, and return a copy with the changes leaving the original in-tact. An exclamation point avoids this copy and modifies the object directly.

    def break_something!
      # something destructive
    end

* *question* *mark*: implies that a boolean will be returned. In languages that lack method suffixes you would write some_array.is_empty to imply a boolean. Avoid is_empty? -- it's redundant: use a suffix or is_ but not both.

    def this_year?(year)
      Time.now.year == year
    end

==== Guard Clause (short-circuit)
* assists with readability - stop executing if this condition otherwise run the method
* if you see a guard clause, you only need to read the whole method half the time ;)

    # standard

    def happy(word)
      if word == 'happy'
        'happy'
      else
        'unhappy'
      end
    end

    # short-circuit version

    def happy(word)
      return 'happy' if word == 'happy'
      'unhappy'
    end

=== Lab 07: Lucky Number [ lab_07_lucky_number.rb ]
* Think of a number. We'll use that one.
* Create a method called lucky? 
* This method should take one number as an argument
* The method should return true or false if the argument is the lucky number

==== Classes
* classes begin with a capital letter
* class methods are defined def self.method_name
* class methods are only available to the class - not to the instance of the class
* private methods are only available inside that class
* protected methods are only avilable to objects of the same type

    class Dog

      def bark
        puts 'Woof'
      end

      def vitals
        "Blood Type: #{blood_type}"
      end

      def self.number_of_legs
        4
      end

      private
        def blood_type
          'F Positive'
        end
    end

    rex = Dog.new
    rex.bark             #=> "Woof"

    rex.number_of_legs  #=> undefined
    Dog.number_of_legs  #=> 4

    rex.blood_type      #=> NoMethodError: private method `blood_type'
    rex.vitals          #=> "Blood Type: F Positive"

==== Open Classes
* if you want to change the behavior of an existing class
* all you need to do is open it an add methods

    class String
      def upcase_reverse
        self.upcase.reverse
      end
    end

    "adam".upcase_reverse #=> "MADA"

    # self refers to the current object/namespace

=== Lab 08: Implement Fixnum#lucky? [ lab_08_fixnum_lucky_number.rb ]
* Think of a number. We'll use that one.
* Open the standard Ruby Fixnum class
* Create a method called lucky? 
* The method should return true or false if the number is the lucky number

=== Lab 09: Implement an Animal Class [ lab_09_animal_class.rb ]
* Create a class called 'Animal'
* Create a method called noise that returns a string

    * Class Inheritance
      shared behavior in the base class
      specific behavior in the subclass
      you can also override 

      class Vehicle
        def wheels
          4
        end
      end

      class Truck < Vehicle
        def four_wheel_drive?
          true
        end
      end

      Vehicle.new.wheels            #=> 4
      Vehicle.new.four_wheel_drive? #=> Undefined Method
      Truck.new.wheels              #=> 4
      Truck.new.four_wheel_drive?   #=> true

=== Lab 10: Subclass the Animal Class [ lab_10_animal_subclass.rb ]
* create an animal that has a noise method
* the noise method should return an empty string
* override the noise method in the subclass
    
==== Object Initialization
* initialize is a special method that is called anytime a new object is created

    class Vehicle
      def initialize
        puts "I'm being created"
      end
    end

    Vehicle.new #=> "I'm being created"

==== Instance Variables
* variables that are specific to a particular instantiated object
* always start with an '@' (at) sign

    class Vehicle
      def initialize(maker)
        @auto_maker = maker
      end

      def auto_maker
        @auto_maker
      end
    end

    Vehicle.new('saab').auto_maker #=> 'saab'
  
==== Accessors (fancy getter/setters)
    attr_reader :variable   #=> you can read the variable: car.variable
    attr_writer :variable   #=> you can write the variable: car.varible = 'something'
    attr_accessor :variable #=> shorthand for attr_writer + attr_reader

    class Vehicle
      attr_reader :auto_maker

      def initialize(maker)
        @auto_maker = maker
      end
    end

Vehicle.new('saab').auto_maker #=> 'saab'

=== Lab 11: Animal Names [ lab_11_animal_names.rb ]
* Using the Animal classes from lab 10
* Add an accessor called :name
* Create an intialize method that sets the name

=== Overflow/Extras (if we run out of time)

==== Modules
* collections of methods
* can be 'mixed in' with classes so that the classes respond to those methods
* nice way to organize specific or common functionality
* ex: Enumerable (each, inject, map)

==== ARGV
* fetching arguments from command line
* default arguments

==== Reading file contents 
* File.open
* IO.readlines 

==== YAML! It's baked right in!
* serialize objects to a file
* marshal ruby objects from a file

    #example

    # write yaml to a file
    open('filename', 'w') {|f| f << something.to_yaml}

    # read yaml from a file
    something = YAML.load(open('filename'))

