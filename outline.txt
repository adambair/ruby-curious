Installfest
  Who needs help getting ruby up and running on their machines?
  We can even start this pre-class if we can get there early
  Might want to mention this in the introduction email (come early for install help?)

  Lab: Install ruby.
  Lab: Rubygems

   - gem install fastercsv
   - gem install twitter 

Ruby Curious

  * not the typical slideshow class, more interactive than that.
    - follow along, type stuff in
    - speak up, discuss it and move on

  * history
    - ruby is almost 15 years old
    - conceived by Yukihiro Matsumoto (Matz) in 1993
    - first public release (0.95) in december 05
    - 1.0 on christmas of 06
    - Ruby-talk mailing list (first in english) started when ruby 1.3 was released in 99

  * philosphy
    - Matz designed Ruby with programmer productivity and happiness in mind
    - Takes the focus away from making the machine run faster -- but instead making the programmer faster, happier and more productive.
    - Ruby follows the principals of the Path of Least Surprise (POLS?). The language was designed to be consistent in how it operates so that ruby programmers can usually guess the right method to use or how something is going to respond/perform/etc.
      
      example:
        String#upcase has a matching #downcase method
        instead of upper and lower (choosing up/down instead for logical consistency)

    - Ruby is fun. It's just more fun to say than Python... way more fun to say then Perl.

    Lab: Can we get Matz to stick his head in the door?

  * introduction to the env 
    filetypes (.rb) 
    commands - ruby, irb 
    explain interpreted language

  * irb - Interactive Ruby Console
    You can execute live Ruby code on the fly
    A great place to test out simple Ruby code
    Mention variables
        store anything
        created on the fly
        lowercase

  * # denotes a comment

  * puts will print a line to the screen automatically adding a new line character
  * print will print a line to the screen without adding a new line character
  * gets 
  * p

  Lab: Simple I/O.  Prompt user for name, repeat NAME to them (we did just
  talk about upcase).

  * object.inspect will give you good information on an object
    - works well when debugging
    - commonly used like:
      puts something.inspect

  * Strings
    - double quotes WILL execute and is called 'String Interpolation'
    - "#{variable} is the value"
    - single quotes will NOT interpolate and execute

      'Happy'           #=> 'happy'
      "Happy #{1+1}"    #=> 'happy 2'
      'Happy ' + 2.to_s #=> 'happy 2'
      'Happy ' += 2     #=> 'happy 2'
      'Happy'.length    #=> 5
      'Happy'.reverse   #=> 'yppaH'
      'Happy'.downcase  #=> 'happy'
      'Happy Birthday'.split #=> ['Happy', 'Birthday']

    - cast a non-String to a String

        5       #=> 5
        5.to_s  #=>"5"

    - substring
       "hello"[0,  1] #=> 'h'
       "hello"[0,  2] #=> 'he'
       "hello"[-1, 1] #=> 'o'
  
  Lab: one word PIG LATIN
    - first letter
    - move it to the end
    - ad ay

  * Integers/Fixnum
      1       #=> 1
      1+1     #=> 2
      1.zero? #=> false

      1.upto(10) do |number|
        puts number
      end

      dividing two integers performs integer division
      3/1.5 => decimal
      3/2 => 1

  * Symbols
      identifiers
      immutable strings

  * Arrays
      Array.new       #=> []
      []              #=> []
      [1,2]           #=> [1, 2]
      [1,2] + [3, 4]  #=> [1,2,3,4]
      [1,2,3].size    #=> 3

      ['car', 'truck'].each do |word|
        puts word
      end

      ['car', 'truck'].map{|w| w.reverse} #=> ['rac', 'kcurt']
  
  Lab Full-on Pig Latin
    convert a sentence to pig latin
    there may be edge cases

  * Ranges
      "a".."z"
      1..100
      upto
      downto

  * Hashes
      Hash.new        #=> {}
      {}              #=> {}
      {'name' => 'jack'}              #=> {'name' => 'jack'}
      {'name' => 'beth', 'age' => 22} #=> {'name' => 'beth', 'age' => 22}

      {'name' => 'beth', 'age' => 22}.each do |key, vale|
        puts "#{key}:#{value}"
      end

  Lab Grocery List
    create a list of groceries 
    print groceries with prices
    sum the prices (total)

  * control structures

    - the common if/else statement
        
        if true
          'do if true'
        else
          'do if false' #=> this is so not going to ever happen
        end
        
    - the less common but more awesome ternary operator 

        true ? 'do if true' : 'do if false'

   Lab: Consonant/vowel (correct) pig latin.

    - the even lesser known and slightly deranged unless
      it's kind of like the reverse polarity if statement
      kind of odd when used on it's own... but it has a neat use case

        unless true
          'do if false'
        else
          'do if true'
        end

    - ruby lets you do awesome thing like this:

        puts 'happy' if adam.happy?

    - but since we have something called unless we can do:
        
        puts 'happy' unless adam.sad? #=> sweet

    - case statement
        case this_name
          when "Jack":
            puts "I am Jack"
          when "Jane":
            puts "I am Jane"
        end

  Lab Ranges and Case statements
    when a..f print something
    when g..z print something
    when 0..50 print something
    when 51..100 print something


  * methods (functions in other languages)
    - always returns the last value in the method
    - return is implicit (only need to call return in specific instances such as 'short-circuiting')
    - an explicit return will stop execution of that method on the line that called return (good for short-circuiting a method)
    - parameters

      def age
        22
      end

      def name
        'jackson'
      end

      # would return 'sven'
      def name
        'bently'
        'sven'
      end

      # would return 'bently'
      def name
        return 'bently'
        'sven'
      end
    - use short-circuit returns to stop methods  mid-way

    Lab: Implement even?(number)

  * methods suffixes
    - exclamation point: usually indicates that something destructive is going to happen.

    - an example of this would be Array#sort!. The Array#sort! method modifies the current object instead of returning a new object with the modifications. Normally Ruby will make a copy of an object, do the requested operation, and return a copy with the changes leaving the original in-tact. An exclamation point avoids this copy and modifies the object directly.

      def break_something!
        # something destructive
      end

    - question mark: implies that a boolean will be returned. In languages that lack method suffixes you would write some_array.is_empty to imply a boolean. Avoid is_empty? -- it's redundant: use a suffix or is_ but not both.

      def this_year?(year)
        Time.now.year == year
      end

  * short-circuiting methods

    standard

      def happy(word)
        if word == 'happy'
          'happy'
        else
          'unhappy'
        end
      end

    Guard Clause - short-circuit version

      def happy(word)
        return 'happy' if word == 'happy'
        'unhappy'
      end

  * Classes
    - classes begin with a capital letter
    - class methods are defined def self.method_name
    - class methods are only available to the class - not to the instance of the class
    - private methods are only available inside that class
    - protected methods are only avilable to objects of the same type

      class Dog
        attr_accessor :name
        def initialize(name="Lassie")
          @name = name
        end

        def bark
          puts 'Woof'
        end

        def vitals
          "Blood Type: #{blood_type}"
        end

        def self.number_of_legs
          4
        end

        private
          def blood_type
            'F Positive'
          end
      end

      rex = Dog.new("Rex") #=> rex is now an instance of the Dog class
      rex.bark             #=> "Woof"
      rex.name             #=> "Rex"

      rex.number_of_legs  #=> undefined
      Dog.number_of_legs  #=> 4

      rex.blood_type      #=> NoMethodError: private method `blood_type'
      rex.vitals          #=> "Blood Type: F Positive"

  * Inheritance
    - subclasses 

      Lab: Implement Fixnum#even?
      Lab: Animal lab.  Subclass .walks_on (returns number of legs).

  * Modules
    - collections of methods
    - can be 'mixed in' with classes so that the classes respond to those methods
    - nice way to organize specific or common functionality
    - ex: Enumerable (each, inject, map)

    Lab: module Eats for Animals

  * ARGV
    - fetching arguments from command line
    - default arguments

  * Reading file contents 
    - File.open
    - IO.readlines 

  * YAML! It's baked right in!
    - serialize and marshal ruby objects to file
    - example
      # write yaml to a file
      open('filename', 'w') {|f| f << something.to_yaml}
      # read yaml from a file
      something = YAML.load(open('filename'))

      Lab: Read yaml file (we'll provide) and pretty print it.

  * Duck Typing

  * RUBY-DOC.org
    - documentation
    - google

